#!/usr/bin/env groovy

pipeline {
    agent any
    
    environment {
        NODE_VERSION = '18'
        DOCKER_REGISTRY = 'your-registry.com'
        IMAGE_NAME = 'newrelic/message-queues-platform'
        HELM_VERSION = '3.12.0'
        KUBECONFIG = credentials('kubeconfig')
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 1, unit: 'HOURS')
        timestamps()
    }
    
    tools {
        nodejs "${NODE_VERSION}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                    env.BUILD_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT_SHORT}"
                }
            }
        }
        
        stage('Setup') {
            parallel {
                stage('Node.js Setup') {
                    steps {
                        sh 'npm ci'
                    }
                }
                
                stage('Docker Setup') {
                    steps {
                        script {
                            docker.withRegistry("https://${DOCKER_REGISTRY}", 'docker-registry-credentials') {
                                sh 'docker --version'
                            }
                        }
                    }
                }
                
                stage('Helm Setup') {
                    steps {
                        sh '''
                            if ! command -v helm &> /dev/null; then
                                curl https://get.helm.sh/helm-v${HELM_VERSION}-linux-amd64.tar.gz | tar -xz
                                sudo mv linux-amd64/helm /usr/local/bin/helm
                                chmod +x /usr/local/bin/helm
                            fi
                            helm version --client
                        '''
                    }
                }
            }
        }
        
        stage('Quality Gates') {
            parallel {
                stage('Lint') {
                    steps {
                        sh 'npm run lint'
                    }
                }
                
                stage('Security Lint') {
                    steps {
                        sh 'npx eslint . --ext .js --config .eslintrc.security.js'
                    }
                }
                
                stage('Helm Lint') {
                    steps {
                        sh '''
                            helm lint helm/message-queues-platform
                            helm template test-release helm/message-queues-platform \\
                                --set secrets.newrelic.accountId=test \\
                                --set secrets.newrelic.apiKey=test \\
                                --set secrets.newrelic.ingestKey=test \\
                                --dry-run --debug
                        '''
                    }
                }
                
                stage('K8s Manifest Validation') {
                    steps {
                        sh '''
                            if ! command -v kubeval &> /dev/null; then
                                wget https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz
                                tar xf kubeval-linux-amd64.tar.gz
                                sudo mv kubeval /usr/local/bin
                            fi
                            find k8s/ -name "*.yaml" -exec kubeval {} \\;
                        '''
                    }
                }
            }
        }
        
        stage('Tests') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        sh 'npm run test:coverage'
                    }
                    post {
                        always {
                            publishCoverage adapters: [
                                coberturaAdapter('coverage/cobertura-coverage.xml')
                            ], sourceFileResolver: sourceFiles('STORE_LAST_BUILD')
                            
                            publishHTML([
                                allowMissing: false,
                                alwaysLinkToLastBuild: true,
                                keepAll: true,
                                reportDir: 'coverage/lcov-report',
                                reportFiles: 'index.html',
                                reportName: 'Coverage Report'
                            ])
                        }
                    }
                }
                
                stage('Integration Tests') {
                    agent {
                        docker {
                            image 'node:18'
                        }
                    }
                    services {
                        docker {
                            image 'confluentinc/cp-zookeeper:latest'
                            args '--name zookeeper -e ZOOKEEPER_CLIENT_PORT=2181 -e ZOOKEEPER_TICK_TIME=2000'
                        }
                        docker {
                            image 'confluentinc/cp-kafka:latest'
                            args '--name kafka --link zookeeper -e KAFKA_BROKER_ID=1 -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092 -e KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1'
                        }
                    }
                    environment {
                        KAFKA_BOOTSTRAP_SERVERS = 'kafka:9092'
                        NEW_RELIC_ACCOUNT_ID = credentials('test-nr-account-id')
                        NEW_RELIC_API_KEY = credentials('test-nr-api-key')
                        NEW_RELIC_INGEST_KEY = credentials('test-nr-ingest-key')
                    }
                    steps {
                        sh 'npm ci'
                        sh 'sleep 30'  // Wait for Kafka to be ready
                        sh 'npm run test:integration'
                    }
                }
            }
        }
        
        stage('Security Scans') {
            parallel {
                stage('Dependency Scan') {
                    steps {
                        sh 'npm audit --audit-level high'
                        sh 'npx license-checker --onlyAllow "MIT;ISC;Apache-2.0;BSD;BSD-2-Clause;BSD-3-Clause;CC0-1.0;Unlicense"'
                    }
                }
                
                stage('Secret Scan') {
                    steps {
                        sh '''
                            if ! command -v gitleaks &> /dev/null; then
                                wget https://github.com/zricethezav/gitleaks/releases/latest/download/gitleaks_linux_x64.tar.gz
                                tar -xzf gitleaks_linux_x64.tar.gz
                                sudo mv gitleaks /usr/local/bin/
                            fi
                            gitleaks detect --verbose --source . || true
                        '''
                    }
                }
                
                stage('Container Scan') {
                    when {
                        anyOf {
                            branch 'main'
                            branch 'develop'
                        }
                    }
                    steps {
                        script {
                            def image = docker.build("${IMAGE_NAME}:${BUILD_TAG}")
                            sh """
                                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \\
                                    -v \$(pwd):/workspace \\
                                    aquasec/trivy:latest image \\
                                    --format template --template "@contrib/sarif.tpl" \\
                                    --output /workspace/trivy-results.sarif \\
                                    ${IMAGE_NAME}:${BUILD_TAG}
                            """
                        }
                    }
                    post {
                        always {
                            archiveArtifacts artifacts: 'trivy-results.sarif', allowEmptyArchive: true
                        }
                    }
                }
            }
        }
        
        stage('Build and Package') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    tag pattern: 'v\\d+\\.\\d+\\.\\d+', comparator: 'REGEXP'
                }
            }
            parallel {
                stage('Docker Build') {
                    steps {
                        script {
                            def image = docker.build("${IMAGE_NAME}:${BUILD_TAG}")
                            
                            docker.withRegistry("https://${DOCKER_REGISTRY}", 'docker-registry-credentials') {
                                image.push()
                                image.push('latest')
                            }
                        }
                    }
                }
                
                stage('Helm Package') {
                    when {
                        tag pattern: 'v\\d+\\.\\d+\\.\\d+', comparator: 'REGEXP'
                    }
                    steps {
                        sh '''
                            helm package helm/message-queues-platform --destination ./helm-packages/
                            ls -la helm-packages/
                        '''
                        archiveArtifacts artifacts: 'helm-packages/*.tgz', allowEmptyArchive: false
                    }
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                branch 'main'
            }
            environment {
                STAGING_NAMESPACE = 'staging'
                NR_ACCOUNT_ID = credentials('staging-nr-account-id')
                NR_API_KEY = credentials('staging-nr-api-key')
                NR_INGEST_KEY = credentials('staging-nr-ingest-key')
            }
            steps {
                script {
                    try {
                        sh """
                            helm upgrade --install message-queues-platform-staging \\
                                helm/message-queues-platform \\
                                --namespace ${STAGING_NAMESPACE} \\
                                --create-namespace \\
                                --set image.tag=${BUILD_TAG} \\
                                --set image.repository=${DOCKER_REGISTRY}/${IMAGE_NAME} \\
                                --set secrets.newrelic.accountId="${NR_ACCOUNT_ID}" \\
                                --set secrets.newrelic.apiKey="${NR_API_KEY}" \\
                                --set secrets.newrelic.ingestKey="${NR_INGEST_KEY}" \\
                                --set platform.mode=simulation \\
                                --set replicaCount=1 \\
                                --wait --timeout=10m
                        """
                        
                        // Smoke tests
                        sh """
                            kubectl wait --for=condition=available --timeout=300s \\
                                deployment/message-queues-platform-staging -n ${STAGING_NAMESPACE}
                            
                            kubectl port-forward svc/message-queues-platform-staging 3000:3000 -n ${STAGING_NAMESPACE} &
                            PF_PID=\$!
                            sleep 10
                            
                            curl -f http://localhost:3000/health
                            curl -f http://localhost:3000/health/live
                            curl -f http://localhost:3000/health/ready
                            curl -f http://localhost:3000/metrics
                            
                            kill \$PF_PID
                        """
                        
                        currentBuild.description = "Deployed to staging: ${BUILD_TAG}"
                    } catch (Exception e) {
                        currentBuild.result = 'UNSTABLE'
                        error("Staging deployment failed: ${e.getMessage()}")
                    }
                }
            }
        }
        
        stage('Deploy to Production') {
            when {
                tag pattern: 'v\\d+\\.\\d+\\.\\d+', comparator: 'REGEXP'
            }
            environment {
                PRODUCTION_NAMESPACE = 'production'
                NR_ACCOUNT_ID = credentials('prod-nr-account-id')
                NR_API_KEY = credentials('prod-nr-api-key')
                NR_INGEST_KEY = credentials('prod-nr-ingest-key')
            }
            input {
                message "Deploy to production?"
                ok "Deploy"
                parameters {
                    choice(
                        name: 'DEPLOY_MODE',
                        choices: ['infrastructure', 'simulation', 'hybrid'],
                        description: 'Platform mode for production deployment'
                    )
                }
            }
            steps {
                script {
                    try {
                        sh """
                            helm upgrade --install message-queues-platform-prod \\
                                helm/message-queues-platform \\
                                --namespace ${PRODUCTION_NAMESPACE} \\
                                --create-namespace \\
                                --set image.tag=${TAG_NAME} \\
                                --set image.repository=${DOCKER_REGISTRY}/${IMAGE_NAME} \\
                                --set secrets.newrelic.accountId="${NR_ACCOUNT_ID}" \\
                                --set secrets.newrelic.apiKey="${NR_API_KEY}" \\
                                --set secrets.newrelic.ingestKey="${NR_INGEST_KEY}" \\
                                --set platform.mode=${DEPLOY_MODE} \\
                                --set replicaCount=3 \\
                                --set autoscaling.enabled=true \\
                                --set autoscaling.maxReplicas=10 \\
                                --set monitoring.enabled=true \\
                                --wait --timeout=15m
                        """
                        
                        sh """
                            kubectl wait --for=condition=available --timeout=600s \\
                                deployment/message-queues-platform-prod -n ${PRODUCTION_NAMESPACE}
                            
                            kubectl get pods -n ${PRODUCTION_NAMESPACE} -l app.kubernetes.io/name=message-queues-platform
                            kubectl get hpa -n ${PRODUCTION_NAMESPACE}
                        """
                        
                        currentBuild.description = "Deployed to production: ${TAG_NAME}"
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Production deployment failed: ${e.getMessage()}")
                    }
                }
            }
        }
    }
    
    post {
        always {
            // Clean up workspace
            cleanWs()
        }
        
        success {
            emailext(
                subject: "✅ Pipeline Success: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                body: """
                Pipeline completed successfully!
                
                Job: ${env.JOB_NAME}
                Build: ${env.BUILD_NUMBER}
                Branch: ${env.BRANCH_NAME}
                Commit: ${env.GIT_COMMIT_SHORT}
                
                Build URL: ${env.BUILD_URL}
                """,
                to: "${env.CHANGE_AUTHOR_EMAIL}",
                recipientProviders: [developers(), requestor()]
            )
            
            slackSend(
                channel: '#deployments',
                color: 'good',
                message: ":white_check_mark: Pipeline Success: ${env.JOB_NAME} - ${env.BUILD_NUMBER}"
            )
        }
        
        failure {
            emailext(
                subject: "❌ Pipeline Failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                body: """
                Pipeline failed!
                
                Job: ${env.JOB_NAME}
                Build: ${env.BUILD_NUMBER}
                Branch: ${env.BRANCH_NAME}
                Commit: ${env.GIT_COMMIT_SHORT}
                
                Build URL: ${env.BUILD_URL}
                Console: ${env.BUILD_URL}console
                """,
                to: "${env.CHANGE_AUTHOR_EMAIL}",
                recipientProviders: [developers(), requestor(), culprits()]
            )
            
            slackSend(
                channel: '#deployments',
                color: 'danger',
                message: ":x: Pipeline Failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}"
            )
        }
        
        unstable {
            slackSend(
                channel: '#deployments',
                color: 'warning',
                message: ":warning: Pipeline Unstable: ${env.JOB_NAME} - ${env.BUILD_NUMBER}"
            )
        }
    }
}