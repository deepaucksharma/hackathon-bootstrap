# Entity Synthesis Master Plan

## Part 1: The "Why" - The Theoretical Foundation (The Learnings)

### 1.1 The New Relic Entity Model & entity-definitions

**The Truth**: The `newrelic/entity-definitions` repository provides the synthesis rules, not a simple field map. It tells us how entities are linked and what attributes define their identity (e.g., `aws.accountId + aws.region + aws.kafka.ClusterName` uniquely identifies an MSK cluster).

**Key Insight**: Entity synthesis is a backend process triggered by specific data patterns. Our goal is not just to send data, but to send it in a pattern that activates the correct synthesis rule.

**Actionable Consequence**: We must construct our payloads to satisfy these identity-defining attributes precisely. The entity's GUID itself is a base64 encoding of these identity parts.

### 1.2 The Queues & Streams UI Requirements

**The Truth**: The New Relic Q&S UI is not just a generic data visualizer. It is a curated application experience that expects entities to have a specific provider tag and be generated by a trusted source.

**Key Insight**: Analysis of working accounts and our own experiments proved the UI filters for data coming from the `cloud-integrations` collector pipeline, which is used by New Relic's native AWS polling integrations.

**Actionable Consequence**: All other approaches (mimicking CloudWatch Metric Streams, sending generic Metric events) are incorrect. We must perfectly emulate the `AwsMsk*Sample` event format sent by the polling integrations.

### 1.3 The Data Format: Aggregated Events

**The Truth**: The `cloud-integrations` pipeline sends pre-aggregated data. It doesn't send raw, high-frequency metrics.

**Key Insight**: Every single metric must be accompanied by a full set of five aggregation types: `.Sum`, `.Average`, `.Maximum`, `.Minimum`, and `.SampleCount`. A metric like `provider.bytesInPerSec.Average` without the other four will likely be ignored by UI components.

**Actionable Consequence**: Our payload generation must perform these aggregations over a simulated time window before sending the data.

## Part 2: The "What" - The Golden Payload Schema

This is the definitive, annotated structure that our platform must produce. It is the blueprint for success.

```jsonc
// The "Golden" schema for an AwsMskBrokerSample event
{
  // --- A. Event & Timestamp ---
  "eventType": "AwsMskBrokerSample", // REQUIRED: Triggers the correct processing pipeline.
  "timestamp": 1672531200000,        // REQUIRED: Unix timestamp in MILLISECONDS.

  // --- B. Entity Identity (CRITICAL) ---
  "entityName": "1:my-local-kafka", // REQUIRED: Format is "{brokerId}:{clusterName}".
  "entityGuid": "...",              // REQUIRED: base64(accountId|INFRA|AWS_KAFKA_BROKER|hash(identifier)).
  "entityId": 123456789,            // REQUIRED: Numeric hash of the identifier.

  // --- C. Collector & Provider Identity (CRITICAL FOR UI VISIBILITY) ---
  "collector.name": "cloud-integrations",     // NON-NEGOTIABLE: This is the magic key for the UI.
  "instrumentation.provider": "aws",          // REQUIRED: Identifies the data source as AWS-native.
  "provider": "AwsMskBroker",                 // REQUIRED: Must be "AwsMskBroker", "AwsMskCluster", or "AwsMskTopic".

  // --- D. Account Mapping (CRITICAL FOR UI VISIBILITY) ---
  "providerAccountId": "YOUR_NR_ACCOUNT_ID",   // Your New Relic Account ID.
  "providerAccountName": "My Kafka Cluster",   // Display name for the account link.
  "providerExternalId": "YOUR_AWS_ACCOUNT_ID", // Your 12-digit AWS Account ID. Links to AWS account in NR.

  // --- E. AWS Contextual Attributes ---
  "awsAccountId": "YOUR_AWS_ACCOUNT_ID",   // Your 12-digit AWS Account ID.
  "awsRegion": "us-east-1",                // The AWS region.
  "dataSourceName": "Managed Kafka",       // Static value used by the native integration.

  // --- F. Broker-Specific Identifiers ---
  "provider.brokerId": "1",
  "provider.clusterName": "my-local-kafka", // Must match the cluster's entityName to establish relationships.

  // --- G. The Metrics (MUST include all 5 aggregations) ---
  "provider.bytesInPerSec.Sum": 150000.0,
  "provider.bytesInPerSec.Average": 2500.0,
  "provider.bytesInPerSec.Maximum": 5000.0,
  "provider.bytesInPerSec.Minimum": 1000.0,
  "provider.bytesInPerSec.SampleCount": 60,
  // ... more metrics in the same format
}
```

## Part 3: The "How" - The ESVP (Entity Synthesis & Verification Platform)

### Step 3.1: Platform Architecture & Tooling

**Directory Structure**: The refined structure from our previous discussion is perfect. It separates configuration, executable experiments, source code, and results.

**Master Scripts**:
- `1-run-experiment.js`: Executes a single, atomic YAML test file. Ideal for debugging.
- `2-run-campaign.js`: Executes all YAML files in a phase directory (e.g., `phase-2-deconstruction`). This automates the knowledge-building process.

**Configuration (`config/`)**:
- `platform-config.json`: Centralizes all variables (API keys, account IDs, wait times). This keeps tests clean.
- `entity-schema.json`: This file will be the output of the campaignâ€”the programmatically verified "golden schema."

### Step 3.2: The Execution Campaign - A Rigorous Path to Mastery

This campaign uses the ESVP to leave no stone unturned.

#### Phase 1: Baseline Validation (Control Experiments)
**Goal**: Prove the platform works and validate our core discovery.

**Action**: Run the `phase-1-baseline-validation` campaign.
- `1.1-positive-control.yaml`: Sends the captured golden-payload. Verification: All checks, including `entityIsVisibleInUi`, must PASS.
- `1.2-negative-control-wrong-collector.yaml`: Sends the golden payload but with `collector.name: "nri-kafka"`. Verification: `entityIsVisibleInUi` MUST FAIL.

**Outcome**: A permanent, data-backed artifact proving that the `cloud-integrations` collector is the key.

#### Phase 2: Minimal Viable Payload Deconstruction
**Goal**: Find the absolute minimum set of fields required for UI visibility.

**Action**: Run the `phase-2-deconstruction-analysis` campaign. This campaign directory contains one YAML file for each attribute in the golden payload. Each experiment removes a single attribute.

**Example** (`2.1-remove-providerExternalId.yaml`):
- modification: `remove: "providerExternalId"`
- verification: `entityIsVisibleInUi` (expected to FAIL).

**Outcome**: The `results/campaign-log.md` is automatically updated with a table that classifies each attribute as:
- `MANDATORY_FOR_UI`: Test failed `entityIsVisibleInUi`.
- `MANDATORY_FOR_ENTITY`: Test failed `entityExists`.
- `RECOMMENDED`: Test passed, but is present in all working examples.
- `OPTIONAL`: Test passed, and is not always present.

#### Phase 3: UI Component & Behavior Verification
**Goal**: Confirm how to control specific UI elements.

**Action**: Run the `phase-3-component-verification` campaign.

**Example** (`3.1-trigger-unhealthy-status.yaml`):
- Modification: `set: "provider.offlinePartitionsCount.Sum": 1`.
- Verification: `healthStatusShouldBe(guid, 'UNHEALTHY')`.

**Outcome**: A clear understanding of the data-to-UI mapping, codified in executable tests.

#### Phase 4: Full System Simulation & Relationship Synthesis
**Goal**: Verify complex interactions in a multi-entity environment.

**Action**: Run the `2-run-simulation.js` script with a scenario file.

**Scenario** (`simulations/1-full-cluster-lifecycle.yaml`):
- send a cluster payload.
- send three broker payloads, each containing the cluster's entityName in their `provider.clusterName` attribute.
- wait for synthesis.
- verify using `relationshipExists` to confirm that all three brokers are now children of the cluster.

**Outcome**: Proof that our understanding of entity hierarchy and relationships is correct.

## Part 4: The Final Deliverable - From Platform to Production

The ESVP is not the final product; it is the factory that produces the final specification.

1. **Generate the Golden Schema**: At the end of the campaign, run a script to analyze the successful test results and auto-generate the `config/entity-schema.json`. This file represents the data-backed, validated, minimal-but-complete specification.

2. **Implement in nri-kafka**: The nri-kafka development team now has an unambiguous, machine-readable specification. Their task is to modify the Go application's MSK shim to produce JSON payloads that are 100% compliant with the `entity-schema.json`.

3. **CI/CD Integration**: The `2-run-campaign.js` script becomes a critical part of the CI/CD pipeline for nri-kafka. Before any new version is released, it must pass the full verification campaign, ensuring that no code change accidentally breaks the fragile but now understood payload format.

This ultra-detailed, ground-up solution provides a complete, closed-loop system. It begins with observation, moves to rigorous experimentation, produces a verifiable specification, and provides a mechanism for ongoing automated regression testing. It is the most effective path to a successful and maintainable integration.